import Foundation
import Rainbow
import GraphQL
import Meta

public final class Generator {
    
    private let schemaPath: String
    private let inputPath: String
    private let outputPath: String
    private let fileManager: FileManager
    
    private var objectDefinitions: [String: ObjectTypeDefinition] = [:]
    private var unionDefinitions: [String: UnionTypeDefinition] = [:]
    private var interfaceDefinitions: [String: InterfaceTypeDefinition] = [:]
    private var enumDefinitions: [String: EnumTypeDefinition] = [:]
    
    private var usedEnumTypes: [String] = []
    
    public init(schemaPath: String,
                inputPath: String,
                outputPath: String,
                fileManager: FileManager = .default) {
        self.schemaPath = schemaPath
        self.inputPath = inputPath
        self.outputPath = outputPath
        self.fileManager = fileManager
    }
    
    public func generate() throws {
        let workingDirectory = getWorkingDirectory()
        
        let schemaData = try Data(contentsOf: URL(fileURLWithPath: workingDirectory + schemaPath))
        guard let schemaString = String(data: schemaData, encoding: .utf8) else {
            throw GraphQLGeneratorError.schemaNotRead
        }

        var objects: [String] = []
        let enumerator = fileManager.enumerator(atPath: inputPath)
        while let element = enumerator?.nextObject() as? String {
            guard element.hasSuffix(".graphql") else { continue }
            let data = try Data(contentsOf: URL(fileURLWithPath: workingDirectory + inputPath + "/" + element))
            guard let string = String(data: data, encoding: .utf8) else {
                print("Unable to read contents of \(element)".red)
                continue
            }
            objects.append(string)
        }
        let combinedObjects = objects.joined(separator: "\n")
        
        let schema = try parse(source: .init(body: schemaString))
        let document = try parse(source: .init(body: combinedObjects))
        
        var members: [FileBodyMember] = []
        
        schema.definitions.forEach { definition in
            switch definition {
                case let objectDefinition as ObjectTypeDefinition:
                    objectDefinitions[objectDefinition.name.value] = objectDefinition
                case let unionDefinition as UnionTypeDefinition:
                    unionDefinitions[unionDefinition.name.value] = unionDefinition
                case let interfaceDefinition as InterfaceTypeDefinition:
                    interfaceDefinitions[interfaceDefinition.name.value] = interfaceDefinition
                case let enumDefinition as EnumTypeDefinition:
                    enumDefinitions[enumDefinition.name.value] = enumDefinition
                default: return
            }
        }
        
        let fragmentDefinitions = document.definitions.compactMap { $0 as? FragmentDefinition }
        for (index, definition) in document.definitions.enumerated() {
            let start = definition.loc?.start ?? 0
            let end = document.definitions[safe: index + 1]?.loc?.start ?? combinedObjects.count
            let startIndex = combinedObjects.index(combinedObjects.startIndex, offsetBy: start)
            let index = combinedObjects.index(startIndex, offsetBy: end - start)
            let definitionString = combinedObjects[startIndex..<index].trimmingCharacters(in: .newlines)
            switch definition {
                case let operation as OperationDefinition:
                    try members.append(mapOperation(operation, schema: schema, fragments: fragmentDefinitions, definition: definitionString))
                case let fragment as FragmentDefinition:
                    try members.append(mapFragment(fragment, schema: schema, definition: definitionString))
                default: fatalError("Unsupported definition")
            }
            members.append(EmptyLine())
        }
        usedEnumTypes.forEach { enumType in
            guard let match = enumDefinitions[enumType] else { return }
            var enumNode = Meta.Type(identifier: .named(enumType)).with(kind: .enum(indirect: false)).adding(inheritedType: .string).adding(inheritedTypes: [.decodable, .equatable]).with(accessLevel: .public)
            let sortedCases = match.values.sorted(by: { $0.name.value < $1.name.value })
            sortedCases.forEach { value in
                enumNode = enumNode.adding(member: Case(name: value.name.value))
            }
            members.append(enumNode)
        }
        let file = File(name: "Meta")
            .with(imports: [Import(name: "Foundation")])
            .with(header: [.empty,
                           .comment("Generated by SWiftGraphQLGenerator"),
                           .comment("DO NOT MODIFY!"),
                           .empty])
            .adding(members: members)
        let outputDirectoryPath = outputPath.split(separator: "/").dropLast().joined(separator: "/")
        try fileManager.createDirectory(atPath: outputDirectoryPath, withIntermediateDirectories: true, attributes: nil)
        let created = fileManager.createFile(atPath: outputPath, contents: file.swiftString.data(using: .utf8), attributes: nil)
        if created {
            print("Generated `\(outputPath)` file".green)
        } else {
            print("Error writing to `\(outputPath)".red)
        }
    }
    
    /// Resolve a GraphQL type to a Swif type.
    /// - Parameters:
    ///   - type: Provided GraphQL type
    ///   - wrapInTopLevelOptional: This boolean is usefull for mapping to a type for initialisers. Optional types should be read with the decoder by using the `decodeIfPresent` method. Thus we don't want to provide the top level optional.
    /// - Throws: `GraphQLGeneratorError.namelessType` if there is no named type embedded.
    /// - Returns: Tuple containing the resolved type, string value containing the top level type, boolean indicating if value optional
    func resolveType(_ type: GraphQL.`Type`, wrapInTopLevelOptional: Bool = true) throws -> (type: TypeIdentifier, name: String, isOptional: Bool) {
        var typeIdentifier: TypeIdentifier?
        var isOptional = false
        var typeName: String?
        // Map type to array and run through them in reverse starting with the outer type. That way we can map them into each other.
        // Each `NamedType` or `ListType` is directly inferred as a optional type. This will be overriden by the next `NonNullType` if no `
        for type in type.toArray().reversed() {
            if type is NonNullType {
                isOptional = false
                continue
            }
            if isOptional {
                typeIdentifier = .optional(wrapped: typeIdentifier)
                isOptional = false
            }
            if type is ListType {
                typeIdentifier = .array(element: typeIdentifier)
                isOptional = true
            } else if let named = type as? NamedType {
                // If we encounter a Primitive we use the appropriate Swift type other types are custom and rely on either scalars or object types defined in the schema
                let sanitizedType: TypeIdentifierName = Primitives(rawValue: named.name.value)?.type ?? .custom(named.name.value)
                typeIdentifier = .init(name: sanitizedType)
                isOptional = true
                typeName = named.name.value
            }
        }
        if isOptional, wrapInTopLevelOptional {
            typeIdentifier = .optional(wrapped: typeIdentifier)
        }
        // We didn't encounter a `NamedType` this is an error, top most type should always be named.
        guard let type = typeIdentifier, let name = typeName else {
            throw GraphQLGeneratorError.namelessType
        }
        return (type, name, isOptional)
    }

    func mapType(_ type: GraphQL.`Type`, name: String) throws -> (TypeBodyMember, String) {
        let (type, typeName, _) = try resolveType(type)
        return (Property(variable:
            Variable(name: name)
                .with(immutable: true)
                .with(type: type)
        ).with(accessLevel: .public), typeName)
    }
    
    func addVariableDefinitions(_ variables: [VariableDefinition], to: inout Meta.`Type`) throws {
        guard !variables.isEmpty else { return }
        to = to.adding(member: Property(variable: Variable(name: "variables").with(type: TypeIdentifier(name: "Variables"))).with(accessLevel: .public))
        to = to.adding(member: EmptyLine())
        
        var initFunction = Function(kind: .`init`).with(accessLevel: .public)
        initFunction = initFunction.adding(parameter: FunctionParameter(name: "variables", type: TypeIdentifier(name: "Variables")))
        initFunction = initFunction.adding(member: Assignment(variable: Reference.dot(.named("self"), .named("variables")), value: Reference.named("variables")))
        to = to.adding(member: initFunction)
        
        to = to.adding(member: EmptyLine())
        
        var variablesStruct = Meta.Type(identifier: .init(name: "Variables")).with(kind: .struct).adding(inheritedTypes: [.encodable, .equatable]).with(accessLevel: .public)
        variablesStruct = variablesStruct.adding(member: EmptyLine())
        var variablesInit = Function(kind: .`init`).with(accessLevel: .public)
        try variables.forEach { variable in
            variablesStruct = variablesStruct.adding(member: try mapType(variable.type, name: variable.variable.name.value).0)
            let typeName = try mapType(variable.type, name: variable.variable.name.value).1
            variablesInit = variablesInit.adding(parameter: FunctionParameter(name: variable.variable.name.value, type: TypeIdentifier(name: typeName)))
            variablesInit = variablesInit.adding(member: Assignment(variable: Reference.dot(.named("self"), .named(variable.variable.name.value)), value: Reference.named(variable.variable.name.value)))
        }
        variablesStruct = variablesStruct.adding(member: EmptyLine())
        variablesStruct = variablesStruct.adding(member: variablesInit)
        to = to.adding(member: variablesStruct)
    }

    func mapOperation(_ operation: OperationDefinition, schema: Document, fragments: [FragmentDefinition], definition: String) throws -> FileBodyMember {
        guard let name = operation.name?.value else {
            throw GraphQLGeneratorError.noQueryName
        }
        print("Generating operation `\(name)` of type `\(operation.operation)`".yellow)
        
        var fragmentStrings: [String] = []
        var data = Meta.Type(identifier: .init(name: "Data")).with(kind: .struct).adding(inheritedTypes: [.decodable, .equatable]).with(accessLevel: .public)
        try operation.selectionSet.selections.forEach { selection in
            guard let field = selection as? Field else {
                throw GraphQLGeneratorError.invalidSelectionType
            }
            let propertyName = field.alias?.value ?? field.name.value
            let type: FieldDefinition?
            switch operation.operation {
                case .query:
                    type = objectDefinitions["Query"]?.fields.first(where: { $0.name.value == field.name.value })
                case .mutation:
                    type = objectDefinitions["Mutation"]?.fields.first(where: { $0.name.value == field.name.value })
                case .subscription: fatalError("Not supported")
            }
            guard let queriedType = type else { throw GraphQLGeneratorError.unexpectedType }
            
            let (member, name) = try mapType(queriedType.type, name: propertyName)
            data = data.adding(member: EmptyLine())
            data = data.adding(member: member)
            
            guard let selectionSet = field.selectionSet else { return }
            let selectionMember = try mapSelectionSet(selectionSet, typeName: name, definitions: schema.definitions)
            data = data.adding(member: EmptyLine())
            data = data.adding(member: selectionMember)
            
            var usedFragments = try findUsedFragments(in: selectionSet, type: name, definitions: schema.definitions)
            fragmentStrings.append(contentsOf: usedFragments)
            repeat {
                let usedFragmentDefinitions = fragments.filter { usedFragments.contains($0.name.value) }
                var usedNestedFragments: [String] = []
                try usedFragmentDefinitions.forEach { fragment in
                    let nestedFragments = try findUsedFragments(in: fragment.selectionSet, type: fragment.typeCondition.name.value, definitions: schema.definitions)
                    usedNestedFragments.append(contentsOf: nestedFragments)
                }
                usedFragments = usedNestedFragments
                fragmentStrings.append(contentsOf: usedFragments)
            } while !usedFragments.isEmpty
        }
        
        var member = Meta.Type(identifier: .init(name: name)).with(kind: .struct).adding(inheritedTypes: [.encodable, .equatable]).with(accessLevel: .public)
        member = member.adding(member: EmptyLine())
        
        var variable: VariableValue = PlainCode(code: "\n\"\"\"\n\(definition)\n\"\"\"")
        Set(fragmentStrings).sorted().forEach { fragment in
            variable = LogicalStatement.assemble(.value(variable), .plus, .value(Value.reference(.dot(.named(fragment), .named("definition")))))
        }
        let definitionProperty = Property(variable: Variable(name: "definition").with(static: true)).with(value: variable)
        member = member.adding(member: definitionProperty)
        member = member.adding(member: EmptyLine())
        
        member = member.adding(member: Property(variable: Variable(name: "query")).with(accessLevel: .public).with(value: Value.reference(.dot(.named("Self"), .named("definition")))))
        member = member.adding(member: Property(variable: Variable(name: "operationName")).with(accessLevel: .public).with(value: Value.string(name)))
        try addVariableDefinitions(operation.variableDefinitions, to: &member)
        
        member = member.adding(member: EmptyLine())
        member = member.adding(member: data)
        return member
    }

    func generateCodingKeys(_ selectionSet: SelectionSet) -> TypeBodyMember {
        var enumType = Meta.Type(identifier: .named("CodingKeys")).with(kind: .enum(indirect: false)).adding(inheritedType: .string).adding(inheritedType: .named("CodingKey")).with(accessLevel: .public)
        selectionSet.selections.forEach { selection in
            if let field = selection as? Field {
                let name = field.alias?.value ?? field.name.value
                enumType = enumType.adding(member: Case(name: name))
            } else if let fragment = selection as? FragmentSpread {
                let name = fragment.name.value.lowercasingFirstLetter()
                enumType = enumType.adding(member: Case(name: name))
            }
        }
        return enumType
    }

    func generateInit(_ selectionSet: SelectionSet, definition: ObjectTypeDefinition) throws -> TypeBodyMember {
        var function = Function(kind: .`init`).with(throws: true).with(accessLevel: .public)
        .adding(parameter:
            FunctionParameter(alias: "from", name: "decoder", type: .named("Decoder"))
            )
        if selectionSet.selections.contains(where: { $0 is Field }) { // Only add values keys if we are going to use it
            function = function.adding(member: Assignment(
                variable: Variable(name: "values"),
                value: .try | .dot(.named("decoder"), .named("container")) | .call(Tuple().adding(parameter: TupleParameter(name: "keyedBy", value: Value.reference(.dot(.named("CodingKeys"), .named("self"))))))
            ))
        }
        try selectionSet.selections.forEach { selection in
            if let field = selection as? Field {
                let name = field.alias?.value ?? field.name.value
                guard let definition = definition.fields.first(where: { $0.name.value == field.name.value }) else { return }
                let (property, _, isOptional) = try resolveType(definition.type, wrapInTopLevelOptional: false)
                let reference = Reference.type(property)
                let method: Reference = isOptional ? .named("decodeIfPresent") : .named("decode")
                 let tuple = Tuple()
                    .adding(parameter: TupleParameter(value: Value.reference(.dot(reference, .named("self")))))
                    .adding(parameter: TupleParameter(name: "forKey", value: Value.reference(.dot(.named("CodingKeys"), .named(name)))))
                function = function.adding(member: Assignment(variable: Reference.named(name), value: .try |
                    .dot(.named("values"), method) |
                    .call(tuple)))
            } else if let fragment = selection as? FragmentSpread {
                let name = fragment.name.value.lowercasingFirstLetter()
                let tuple = Tuple().adding(parameter: TupleParameter(name: "from", value: Value.reference(.named("decoder"))))
                function = function.adding(member: Assignment(variable: Reference.named(name), value: .try | .named(fragment.name.value) | .call(tuple)))
            }
        }
        return function
    }
    
    func generateInit(_ selectionSet: SelectionSet, definition: InterfaceTypeDefinition, inlineFragmentDefinitions: [(type: String, fragment: InlineFragment, count: Int?)]) throws -> TypeBodyMember {
        var function = Function(kind: .`init`).with(throws: true).with(accessLevel: .public)
        .adding(parameter:
            FunctionParameter(alias: "from", name: "decoder", type: .named("Decoder"))
            )
        if selectionSet.selections.contains(where: { $0 is Field }) { // Only add values keys if we are going to use it
            function = function.adding(member: Assignment(
                variable: Variable(name: "values"),
                value: .try | .dot(.named("decoder"), .named("container")) | .call(Tuple().adding(parameter: TupleParameter(name: "keyedBy", value: Value.reference(.dot(.named("CodingKeys"), .named("self"))))))
            ))
        }
        try selectionSet.selections.forEach { selection in
            if let field = selection as? Field {
                let name = field.alias?.value ?? field.name.value
                guard let definition = definition.fields.first(where: { $0.name.value == field.name.value }) else { return }
                let (property, _, isOptional) = try resolveType(definition.type, wrapInTopLevelOptional: false)
                let reference = Reference.type(property)
                let method: Reference = isOptional ? .named("decodeIfPresent") : .named("decode")
                 let tuple = Tuple()
                    .adding(parameter: TupleParameter(value: Value.reference(.dot(reference, .named("self")))))
                    .adding(parameter: TupleParameter(name: "forKey", value: Value.reference(.dot(.named("CodingKeys"), .named(name)))))
                function = function.adding(member: Assignment(variable: Reference.named(name), value: .try |
                    .dot(.named("values"), method) |
                    .call(tuple)))
            } else if let fragment = selection as? FragmentSpread {
                let name = fragment.name.value.lowercasingFirstLetter()
                let tuple = Tuple().adding(parameter: TupleParameter(name: "from", value: Value.reference(.named("decoder"))))
                function = function.adding(member: Assignment(variable: Reference.named(name), value: .try | .named(fragment.name.value) | .call(tuple)))
            }
        }
        let inlineFragmentTypes = Set(inlineFragmentDefinitions.map { $0.type }).sorted(by: { $0 < $1 })
        if inlineFragmentTypes.count > 0 {
            function = function.adding(member: Assignment(
                variable: Variable(name: "type"),
                value: .try | .dot(.named("values"), .named("decode")) | .call(Tuple().adding(parameter: TupleParameter(value: Value.reference(.dot(.type(.named("String")), .named("self"))))).adding(parameter: TupleParameter(name: "forKey", value: Value.reference(.named(".__typename")))))))
            var initSwitch = Switch(reference: .named("type"))
            inlineFragmentTypes.forEach { type in
                var switchCase = SwitchCase(name: .raw("\"\(type)\""))
                inlineFragmentDefinitions.forEach { (current) in
                    let (fragmentType, _, count) = current
                    let typeName: String
                    if let count = count {
                        typeName = fragmentType + "\(count)"
                    } else {
                        typeName = fragmentType
                    }
                    if fragmentType == type {
                        let variable = .optionalTry | .named(typeName) | .tuple(Tuple().adding(parameter: TupleParameter(name: "from", value: Value.reference(.named("decoder")))))
                        let assignment = Assignment(variable: Reference.named("as" + typeName), value: variable)
                        switchCase = switchCase.adding(member: assignment)
                    } else {
                        let assignment = Assignment(variable: Reference.named("as" + typeName), value: Value.nil)
                        switchCase = switchCase.adding(member: assignment)
                    }
                }
                initSwitch = initSwitch.adding(case: switchCase)
            }
            var switchCase = SwitchCase(name: .default)
            inlineFragmentDefinitions.forEach { (current) in
                let (fragmentType, _, count) = current
                let typeName: String
                if let count = count {
                    typeName = fragmentType + "\(count)"
                } else {
                    typeName = fragmentType
                }
                let assignment = Assignment(variable: Reference.named("as" + typeName), value: Value.nil)
                switchCase = switchCase.adding(member: assignment)
            }
            initSwitch = initSwitch.adding(case: switchCase)
            function = function.adding(member: initSwitch)
            
        }
        return function
    }

    func mapInterfaceSelectionSet(_ selectionSet: SelectionSet, typeName: String, name: String? = nil, definition: InterfaceTypeDefinition, definitions: [Definition]) throws -> TypeBodyMember & FileBodyMember {
        var selectionSetType = Meta.Type(identifier: .init(name: name ?? typeName)).with(kind: .struct).adding(inheritedTypes: [.decodable, .equatable]).with(accessLevel: .public)
        selectionSetType = selectionSetType.adding(member: EmptyLine())
        
        let inlineFragments = selectionSet.selections.compactMap { $0 as? InlineFragment}
        let inlineFragmentDefinitions: [(type: String, fragment: InlineFragment, count: Int?)] = inlineFragments.reduce(into: []) { (result, fragment) in
            guard let type = fragment.typeCondition?.name.value else { return }
            let typeCount = inlineFragments.filter { $0.typeCondition?.name.value == type }.count
            let count: Int?
            if let currentCount = result.last(where: { $0.type == type })?.count {
                count = currentCount + 1
            } else {
                count = typeCount > 1 ? 1 : nil
            }
            result.append((type, fragment, count))
        }.sorted(by: { $0.0 < $1.0 })
        
        var selectionSets: [(SelectionSet, String)] = []
        try selectionSet.selections.forEach { selection in
            guard let field = selection as? Field else { return }
                guard let definition = definition.fields.first(where: { $0.name.value == field.name.value }) else { return }
                let name = field.alias?.value ?? field.name.value
                let type = try mapType(definition.type, name: name)
                let isEnum = enumDefinitions.keys.contains(type.1)
                if isEnum {
                    usedEnumTypes.append(type.1)
                }
                selectionSetType = selectionSetType.adding(member: type.0)
                if let selectionSet = field.selectionSet {
                    selectionSets.append((selectionSet, type.1))
                }
        }
        inlineFragmentDefinitions.forEach { item in
            let (type, _, count) = item
            let typeName: String
            if let count = count {
                typeName = type + "\(count)"
            } else {
                typeName = type
            }
            selectionSetType = selectionSetType.adding(member: Property(variable:
                Variable(name: "as\(typeName)")
                    .with(immutable: true)
                    .with(type: .optional(wrapped: .init(name: typeName)))
            ).with(accessLevel: .public))
        }
        selectionSetType = selectionSetType.adding(member: EmptyLine())
        selectionSetType = selectionSetType.adding(member: generateCodingKeys(selectionSet))
        selectionSetType = selectionSetType.adding(member: EmptyLine())
        selectionSetType = selectionSetType.adding(member: try generateInit(selectionSet, definition: definition, inlineFragmentDefinitions: inlineFragmentDefinitions))
        try selectionSets.forEach { set in
            let (selectionSet, name) = set
            let member = try mapSelectionSet(selectionSet, typeName: name, definitions: definitions)
            selectionSetType = selectionSetType.adding(member: EmptyLine())
            selectionSetType = selectionSetType.adding(member: member)
        }
        
        try inlineFragmentDefinitions.forEach { item in
            let (type, fragment, count) = item
            let typeName: String
            if let count = count {
                typeName = type + "\(count)"
            } else {
                typeName = type
            }
            let member = try mapSelectionSet(fragment.selectionSet, typeName: type, name: typeName, definitions: definitions)
            selectionSetType = selectionSetType.adding(member: EmptyLine())
            selectionSetType = selectionSetType.adding(member: member)
        }
        
        return selectionSetType
    }
    
    func mapObjectSelectionSet(_ selectionSet: SelectionSet, typeName: String, name: String? = nil, addSchemaDefinition: Bool = false, definitionString: String? = nil, definition: ObjectTypeDefinition, definitions: [Definition]) throws -> TypeBodyMember & FileBodyMember {
        var selectionSetType = Meta.Type(identifier: .init(name: name ?? typeName)).with(kind: .struct).adding(inheritedTypes: [.decodable, .equatable]).with(accessLevel: .public)
        selectionSetType = selectionSetType.adding(member: EmptyLine())
        
        var selectionSets: [(SelectionSet, String)] = []
        
        var properties: [TypeBodyMember] = []
        try selectionSet.selections.forEach { selection in
            if let field = selection as? Field {
                guard let definition = definition.fields.first(where: { $0.name.value == field.name.value }) else { return }
                let name = field.alias?.value ?? field.name.value
                let type = try mapType(definition.type, name: name)
                let isEnum = enumDefinitions.keys.contains(type.1)
                if isEnum {
                    usedEnumTypes.append(type.1)
                }
                properties.append(type.0)
                if let selectionSet = field.selectionSet {
                    selectionSets.append((selectionSet, type.1))
                }
            } else if let fragment = selection as? FragmentSpread {
                let property = Property(variable:
                    Variable(name: fragment.name.value.lowercasingFirstLetter())
                        .with(immutable: true)
                        .with(type: .named(fragment.name.value))
                ).with(accessLevel: .public)
                properties.append(property)
            }
        }
        
        var members: [FileBodyMember & TypeBodyMember] = []
        try selectionSets.forEach { set in
            let (selectionSet, name) = set
            let member = try mapSelectionSet(selectionSet, typeName: name, definitions: definitions)
            members.append(EmptyLine())
            members.append(member)
        }
        
        if addSchemaDefinition, let definitionString = definitionString {
            let variable = PlainCode(code: "\n\"\"\"\n\(definitionString)\n\"\"\"")
            let definitionProperty = Property(variable: Variable(name: "definition").with(static: true)).with(value: variable)
            selectionSetType = selectionSetType.adding(member: definitionProperty)
            selectionSetType = selectionSetType.adding(member: EmptyLine())
        }
        
        selectionSetType = selectionSetType.adding(members: properties)
        selectionSetType = selectionSetType.adding(member: EmptyLine())
        selectionSetType = selectionSetType.adding(member: generateCodingKeys(selectionSet))
        selectionSetType = selectionSetType.adding(member: EmptyLine())
        selectionSetType = selectionSetType.adding(member: try generateInit(selectionSet, definition: definition))
        selectionSetType = selectionSetType.adding(members: members)
        
        return selectionSetType
    }

    func mapUnionSelectionSet(_ selectionSet: SelectionSet, typeName: String, name: String? = nil, definition: UnionTypeDefinition, definitions: [Definition]) throws -> TypeBodyMember & FileBodyMember {
        guard selectionSet.selections.contains(where: { ($0 as? Field)?.name.value == "__typename" }) else {
            throw GraphQLGeneratorError.unionWithoutTypename
        }
        let sortedTypes = definition.types.sorted(by: { $0.name.value < $1.name.value })
        var enumType = Meta.Type(identifier: .named(typeName)).with(kind: .enum(indirect: false)).adding(inheritedTypes: [.decodable, .equatable]).with(accessLevel: .public)
        enumType = enumType.adding(member: EmptyLine())
        sortedTypes.forEach { type in
            let name = type.name.value.lowercasingFirstLetter()
            let enumCase = Case(name: name).adding(parameter: CaseParameter(name: name, type: .named(type.name.value)))
            enumType = enumType.adding(member: enumCase)
        }
        
        enumType = enumType.adding(member: EmptyLine())
        var typeEnum = Meta.Type(identifier: .named("ItemType")).with(kind: .enum(indirect: false)).adding(inheritedType: .string).adding(inheritedType: .decodable)
        sortedTypes.forEach { type in
            typeEnum = typeEnum.adding(member: Case(name: type.name.value.lowercasingFirstLetter()).with(value: .string(type.name.value)))
        }
        enumType = enumType.adding(member: typeEnum)
        
        enumType = enumType.adding(member: EmptyLine())
        var codingKeyEnum = Meta.Type(identifier: .named("ItemTypeKey")).with(kind: .enum(indirect: false)).adding(inheritedType: .string).adding(inheritedType: .named("CodingKey"))
        codingKeyEnum = codingKeyEnum.adding(member: Case(name: "typeName").with(value: .string("__typename")))
        
        enumType = enumType.adding(member: codingKeyEnum)
        enumType = enumType.adding(member: EmptyLine())
        
        var initFunction = Function(kind: .`init`).with(throws: true).with(accessLevel: .public)
        .adding(parameter:
            FunctionParameter(alias: "from", name: "decoder", type: .named("Decoder"))
            )
        initFunction = initFunction.adding(member: Assignment(
            variable: Variable(name: "typeValues"),
            value: .try | .dot(.named("decoder"), .named("container")) | .call(Tuple().adding(parameter: TupleParameter(name: "keyedBy", value: Value.reference(.dot(.named("ItemTypeKey"), .named("self"))))))))
        initFunction = initFunction.adding(member: Assignment(
        variable: Variable(name: "type"),
        value: .try | .dot(.named("typeValues"), .named("decode")) | .call(Tuple().adding(parameter: TupleParameter(value: Value.reference(.dot(.type(.named("ItemType")), .named("self"))))).adding(parameter: TupleParameter(name: "forKey", value: Value.reference(.named(".typeName")))))))
        
        var initSwitch = Switch(reference: .named("type"))
        sortedTypes.forEach { type in
            let name = type.name.value.lowercasingFirstLetter()
            var switchCase = SwitchCase(name: .custom(name))
            let variable = .try | .named(type.name.value) | .tuple(Tuple().adding(parameter: TupleParameter(name: "from", value: Value.reference(.named("decoder")))))
            let assignment = Assignment(variable: Reference.named("self"), value: .named(".\(name)") | .call(Tuple().adding(parameter: TupleParameter(name: name, value: variable))))
            switchCase = switchCase.adding(member: assignment)
            initSwitch = initSwitch.adding(case: switchCase)
        }

        initFunction = initFunction.adding(member: initSwitch)
        
        enumType = enumType.adding(member: initFunction)
        
        try sortedTypes.forEach { type in
            enumType = enumType.adding(member: EmptyLine())
            let inlineFragments = selectionSet.selections.compactMap { $0 as? InlineFragment }
            if let selection = inlineFragments.first(where: { $0.typeCondition?.name.value == type.name.value }) {
                let member = try mapSelectionSet(selection.selectionSet, typeName: type.name.value, definitions: definitions)
                enumType = enumType.adding(member: member)
            } else {
                let item = Meta.Type(identifier: .init(name: type.name.value)).with(kind: .struct).adding(inheritedTypes: [.decodable, .equatable]).with(accessLevel: .public)
                enumType = enumType.adding(member: item)
            }
        }
        return enumType
    }

    func mapSelectionSet(_ selectionSet: SelectionSet, typeName: String, name: String? = nil, addSchemaDefinition: Bool = false, definitionString: String? = nil, definitions: [Definition]) throws -> TypeBodyMember & FileBodyMember {
        if let definition = unionDefinitions[typeName] {
            return try mapUnionSelectionSet(selectionSet, typeName: typeName, name: name, definition: definition, definitions: definitions)
        } else if let definition = objectDefinitions[typeName] {
            return try mapObjectSelectionSet(selectionSet, typeName: typeName, name: name, addSchemaDefinition: addSchemaDefinition, definitionString: definitionString, definition: definition, definitions: definitions)
        } else if let definition = interfaceDefinitions[typeName] {
            return try mapInterfaceSelectionSet(selectionSet, typeName: typeName, name: name, definition: definition, definitions: definitions)
        }
        throw GraphQLGeneratorError.unexpectedType
    }
    
    func findUsedFragments(in selectionSet: SelectionSet, type: String, definitions: [Definition]) throws -> [String] {
        var fragments: [String] = []
        if let definition = unionDefinitions[type] {
            let inlineFragments = selectionSet.selections.compactMap { $0 as? InlineFragment }
            try definition.types.forEach { type in
                guard let selection = inlineFragments.first(where: { $0.typeCondition?.name.value == type.name.value }) else { return }
                let usedFragments = try findUsedFragments(in: selection.selectionSet, type: type.name.value, definitions: definitions)
                fragments.append(contentsOf: usedFragments)
            }
            return fragments
        } else if let definition = objectDefinitions[type] {
            try selectionSet.selections.forEach { selection in
                if let field = selection as? Field {
                    guard let selectionSet = field.selectionSet else { return }
                    guard let definition = definition.fields.first(where: { $0.name.value == field.name.value }) else { return }
                    let (_, type, _) = try resolveType(definition.type)
                    let usedFragments = try findUsedFragments(in: selectionSet, type: type, definitions: definitions)
                    fragments.append(contentsOf: usedFragments)
                } else if let fragment = selection as? FragmentSpread {
                    fragments.append(fragment.name.value)
                }
            }
            return fragments
        } else if let definition = interfaceDefinitions[type] {
            let inlineFragments = selectionSet.selections.compactMap { $0 as? InlineFragment}
            let inlineFragmentDefinitions: [(type: String, fragment: InlineFragment)] = inlineFragments.reduce(into: []) { (result, fragment) in
                guard let type = fragment.typeCondition?.name.value else { return }
                result.append((type, fragment))
            }.sorted(by: { $0.0 < $1.0 })
            try inlineFragmentDefinitions.forEach { inlineFragment in
                let (type, fragment) = inlineFragment
                let usedFragments = try findUsedFragments(in: fragment.selectionSet, type: type, definitions: definitions)
                fragments.append(contentsOf: usedFragments)
            }
            try selectionSet.selections.forEach { selection in
                if let field = selection as? Field {
                    guard let selectionSet = field.selectionSet else { return }
                    guard let definition = definition.fields.first(where: { $0.name.value == field.name.value }) else { return }
                    let (_, type, _) = try resolveType(definition.type)
                    let usedFragments = try findUsedFragments(in: selectionSet, type: type, definitions: definitions)
                    fragments.append(contentsOf: usedFragments)
                } else if let fragment = selection as? FragmentSpread {
                    fragments.append(fragment.name.value)
                }
            }
            return fragments
        }
        throw GraphQLGeneratorError.unexpectedType
    }

    func mapFragment(_ fragment: FragmentDefinition, schema: Document, definition: String) throws -> FileBodyMember & TypeBodyMember {
        print("Generating fragment `\(fragment.name.value)`".yellow)
        return try mapSelectionSet(fragment.selectionSet, typeName: fragment.typeCondition.name.value, name: fragment.name.value, addSchemaDefinition: true, definitionString: definition, definitions: schema.definitions)
    }
}

private extension Generator {
    
    func getWorkingDirectory() -> String {
        let cwd = getcwd(nil, Int(PATH_MAX))
        defer {
            free(cwd)
        }
        if let cwd = cwd, let string = String(validatingUTF8: cwd) {
            return string + "/"
        } else {
            return "./"
        }
    }
}
